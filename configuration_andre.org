#+TITLE: Emacs HRS configuration

* Utility functions

Define a big ol' bunch of handy utility functions.

#+BEGIN_SRC emacs-lisp
  (defun hrs/view-buffer-name ()
    "Display the filename of the current buffer."
    (interactive)
    (message (buffer-file-name)))

  (defun hrs/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
       name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (other-window 1))

  (defun hrs/de-unicode ()
    "Tidy up a buffer by replacing all special Unicode characters
       (smart quotes, etc.) with their more sane cousins"
    (interactive)
    (let ((unicode-map '(("[\u2018\|\u2019\|\u201A\|\uFFFD]" . "'")
                         ("[\u201c\|\u201d\|\u201e]" . "\"")
                         ("\u2013" . "--")
                         ("\u2014" . "---")
                         ("\u2026" . "...")
                         ("\u00A9" . "(c)")
                         ("\u00AE" . "(r)")
                         ("\u2122" . "TM")
                         ("[\u02DC\|\u00A0]" . " "))))
      (save-excursion
        (loop for (key . value) in unicode-map
              do
              (goto-char (point-min))
              (replace-regexp key value)))))

  (defun hrs/beautify-json ()
    "Pretty-print the JSON in the marked region. Currently shells
       out to `jsonpp'--be sure that's installed!"
    (interactive)
    (save-excursion
      (shell-command-on-region (mark) (point) "jsonpp" (buffer-name) t)))

  (defun hrs/unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

  (defun hrs/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun hrs/visit-last-dired-file ()
    "Open the last file in an open dired buffer."
    (end-of-buffer)
    (previous-line)
    (dired-find-file))

  (defun hrs/visit-last-migration ()
    "Open the last file in 'db/migrate/'. Relies on projectile. Pretty sloppy."
    (interactive)
    (dired (expand-file-name "db/migrate" (projectile-project-root)))
    (hrs/visit-last-dired-file)
    (kill-buffer "migrate"))

  (defun hrs/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun hrs/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun hrs/insert-random-string (len)
    "Insert a random alphanumeric string of length len."
    (interactive)
    (let ((mycharset "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstyvwxyz"))
      (dotimes (i len)
        (insert (elt mycharset (random (length mycharset)))))))

  (defun hrs/generate-password ()
    "Insert a good alphanumeric password of length 30."
    (interactive)
    (hrs/insert-random-string 30))
#+END_SRC

* UI preferences
** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Hide certain modes from the modeline

I'd rather have only a few necessary mode identifiers on my modeline. This
either hides or "renames" a variety of major or minor modes using the =diminish=
package.

# #+BEGIN_SRC emacs-lisp
#   (defmacro diminish-minor-mode (filename mode &optional abbrev)
#     `(eval-after-load (symbol-name ,filename)
#        '(diminish ,mode ,abbrev)))

#   (defmacro diminish-major-mode (mode-hook abbrev)
#     `(add-hook ,mode-hook
#                (lambda () (setq mode-name ,abbrev))))

#   (diminish-minor-mode 'abbrev 'abbrev-mode)
#   (diminish-minor-mode 'simple 'auto-fill-function)
#   (diminish-minor-mode 'company 'company-mode)
#   (diminish-minor-mode 'eldoc 'eldoc-mode)
#   (diminish-minor-mode 'flycheck 'flycheck-mode)
#   (diminish-minor-mode 'flyspell 'flyspell-mode)
#   (diminish-minor-mode 'global-whitespace 'global-whitespace-mode)
#   (diminish-minor-mode 'projectile 'projectile-mode)
#   (diminish-minor-mode 'ruby-end 'ruby-end-mode)
#   (diminish-minor-mode 'subword 'subword-mode)
#   (diminish-minor-mode 'undo-tree 'undo-tree-mode)
#   (diminish-minor-mode 'yard-mode 'yard-mode)
#   (diminish-minor-mode 'yasnippet 'yas-minor-mode)
#   (diminish-minor-mode 'wrap-region 'wrap-region-mode)

#   (diminish-minor-mode 'paredit 'paredit-mode " π")

#   (diminish-major-mode 'emacs-lisp-mode-hook "el")
#   (diminish-major-mode 'haskell-mode-hook "λ=")
#   (diminish-major-mode 'lisp-interaction-mode-hook "λ")
#   (diminish-major-mode 'python-mode-hook "Py")
# #+END_SRC

* Publishing and task management with Org-mode
** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (org-bullets-mode t)))
#+END_SRC

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

Hide emphasis markers because I view my org text mostly in Emacs itself.
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

** Task and org-capture management

Hide done items from the agenda view.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-skip-scheduled-if-done t)
#+END_SRC

Store my org files in =~/org=, maintain an inbox in Dropbox, define the location
of an index file (my main todo list), and archive finished tasks in
=~/org/archive.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file "~/org/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))
#+END_SRC

I use [[http://agiletortoise.com/drafts/][Drafts]] to create new tasks, format them according to a template, and
append them to an "inbox.org" file in my Dropbox. This function lets me import
them easily from that inbox file to my index.

#+BEGIN_SRC emacs-lisp
  (defun hrs/copy-tasks-from-inbox ()
    (when (file-exists-p org-inbox-file)
      (save-excursion
        (find-file org-index-file)
        (goto-char (point-max))
        (insert-file-contents org-inbox-file)
        (delete-file org-inbox-file))))
#+END_SRC

I store all my todos in =~/org/index.org=, so I'd like to derive my agenda from
there.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-index-file))
#+END_SRC

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+BEGIN_SRC emacs-lisp
  (defun mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key global-map "\C-c\C-x\C-s" 'mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

Take a =screenshot= into a time stamped unique-named file in the
same directory as the org-buffer and insert a link to this file.

#+BEGIN_SRC emacs-lisp
(defun take-org-screenshot ()
  "Take a screenshot into a time stamped unique-named file in the
same directory as the org-buffer and insert a link to this file."
  (interactive)
  ;(org-display-inline-images)
  (setq filename
        (concat
         (make-temp-name
          (concat (file-name-nondirectory (buffer-file-name))
                  "_imgs/"
                  (format-time-string "%Y%m%d_%H%M%S_")) ) ".png"))
  (unless (file-exists-p (file-name-directory filename))
    (make-directory (file-name-directory filename)))
  ; take screenshot
  (if (eq system-type 'darwin)
      (call-process "screencapture" nil nil nil "-i" filename))
  (if (eq system-type 'gnu/linux)
      (call-process "import" nil nil nil filename))
  ; insert into file if correctly taken
  (if (file-exists-p filename)
    (insert (concat "[[file:" filename "]]"))))

  (define-key global-map "\C-x\p" 'take-org-screenshot)
#+END_SRC

**** Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =~/org/blog-ideas.org=,
- Keep a running grocery list in =~/org/groceries.org=, and
- Maintain a todo list in =~/org/index.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("b" "Blog idea"
           entry
           (file (org-file-path "blog-ideas.org"))
           "* TODO %?\n")

          ("g" "Groceries"
           checkitem
           (file (org-file-path "groceries.org")))

          ("l" "Today I Learned..."
           entry
           (file+datetree (org-file-path "til.org"))
           "* %?\n")

          ("r" "Reading"
           checkitem
           (file (org-file-path "to-read.org")))

          ("t" "Todo"
           entry
           (file org-index-file)
           "* TODO %?\n")))
#+END_SRC

When I'm starting an org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

# #+BEGIN_SRC emacs-lisp
#   (add-hook 'org-capture-mode-hook 'evil-insert-state)
# #+END_SRC

**** Keybindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC

Hit =C-c i= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (hrs/copy-tasks-from-inbox)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'open-index-file)
#+END_SRC

Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

** Keybindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
  (define-key global-map "\C-ct" 'org-deadline)
#+END_SRC




Hit =C-c i= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (hrs/copy-tasks-from-inbox)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'open-index-file)
#+END_SRC

Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

Remap some handy keybindings defined in emp-keybindings because
org-mode overwrites them.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "org" (define-key org-mode-map (kbd "C-k") nil)
 (define-key org-mode-map [backspace] nil)
 (define-key org-mode-map (kbd "C-'") nil)
 (define-key org-mode-map (kbd "C-,") nil)
 (define-key org-mode-map (kbd "<M-RET>") nil))
#+END_SRC

** Exporting

Allow export to markdown and beamer (for presentations).

#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

Allow =babel= to evaluate Emacs lisp, Ruby, dot, Gnuplot code, or python.

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (dot . t)
     (gnuplot . t)
     (js . t)
     (python . t)))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Associate the "dot" language with the =graphviz-dot= major mode.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+END_SRC

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+BEGIN_SRC emacs-lisp
  (setq org-export-with-smart-quotes t)
#+END_SRC

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

**** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Include the =minted= package in all of my LaTeX exports.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+END_SRC

**** Exporting projects

I have a few Org project definitions that I maintain in a separate elisp file.

# #+BEGIN_SRC emacs-lisp
#   (load-file ".emacs.d/projects.el")
# #+END_SRC

** TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t)
#+END_SRC

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+END_SRC

* =dired=

Do not send --dired to ls, this gives error.

#+BEGIN_SRC emacs-lisp
(setq dired-use-ls-dired nil)
#+END_SRC

Do not hide dired details. (mode of dired+)

#+BEGIN_SRC emacs-lisp
(setq diredp-hide-details-initially-flag nil)
#+END_SRC

Reuse the current dired-buffer, stops opening dozens of windows.
#+BEGIN_SRC emacs-lisp
(diredp-toggle-find-file-reuse-dir 1)
#+END_SRC



Load up the assorted =dired= extensions.

#+BEGIN_SRC emacs-lisp
  (require 'dired-x)
  (require 'dired+)
  (require 'dired-open)
#+END_SRC

Open media with the appropriate programs.

#+BEGIN_SRC emacs-lisp
  (setq dired-open-extensions
        '(("pdf" . "evince")
          ("mkv" . "vlc")
          ("mp4" . "vlc")
          ("avi" . "vlc")))
#+END_SRC

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

# #+BEGIN_SRC emacs-lisp
#   (setq-default dired-listing-switches "-lhvA")
# #+END_SRC

Use "j" and "k" to move around in =dired=.

# #+BEGIN_SRC emacs-lisp
#   (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
#   (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
# #+END_SRC

Kill buffers of files/directories that are deleted in =dired=.

#+BEGIN_SRC emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+END_SRC

Always copy directories recursively instead of asking every time.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Ask before recursively /deleting/ a directory, though.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'top)
#+END_SRC

* =magit=

Magit custom settings for References buffer.

#+BEGIN_SRC emacs-lisp
(setq magit-refs-show-commit-count nil)
;(setq magit-refs-margin nil)
#+END_SRC

* Editing settings

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

# #+BEGIN_SRC emacs-lisp
#   (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)
# #+END_SRC

** Look for executables in =/usr/local/bin=.

#+BEGIN_SRC emacs-lisp
  (setq exec-path (append exec-path '("/usr/local/bin")))
#+END_SRC
** Use =company-mode= everywhere

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace. (Commented out for now)

#+BEGIN_SRC emacs-lisp
;  (setq-default indent-tabs-mode nil)
#+END_SRC

** Cleanup buffer tabs to whitespace

Function to run before safe to replace tabs with whitespaces. (Commented out for now)

# #+BEGIN_SRC emacs-lisp
# (defun cleanup-buffer-safe ()
#   "Perform a bunch of safe operations on the whitespace content of a buffer.
# Does not indent buffer, because it is used for a before-save-hook, and that
# might be bad."
#   (interactive)
#   (when (not (string-match-p (regexp-quote "akefile") (buffer-file-name)))
#     (untabify (point-min) (point-max))
#     (delete-trailing-whitespace)
#     (set-buffer-file-coding-system 'utf-8)))

# ;; Various superfluous white-space. Just say no.
# (add-hook 'before-save-hook 'cleanup-buffer-safe)

# #+END_SRC

** Configure yasnippet

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
  (yas-global-mode 1)
#+END_SRC

I /don’t/ want =ido= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+BEGIN_SRC emacs-lisp
  (setq yas/indent-line nil)
#+END_SRC

** Configure =abbrev-mode=

My email address is too long, so I like to keep some personal information as
abbreviations.

I'm prefixing them with semicolons to avoid collisions with real words.

#+BEGIN_SRC emacs-lisp
  (define-abbrev-table 'global-abbrev-table
    '((";name" "Harry R. Schwartz")
      (";email" "hello@harryrschwartz.com")
      (";tb" "harry@thoughtbot.com")
      (";site" "http://harryrschwartz.com")))
#+END_SRC

Always enable =abbrev-mode=:

#+BEGIN_SRC emacs-lisp
  (setq-default abbrev-mode t)
#+END_SRC

** Configure =ido=

#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
  (ido-ubiquitous)
  (flx-ido-mode 1) ; better/faster matching
  (setq ido-create-new-buffer 'always) ; don't confirm to create new buffers
  (ido-vertical-mode 1)
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+END_SRC

** Use =smex= to handle =M-x= with =ido=

#+BEGIN_SRC emacs-lisp
  (smex-initialize)

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+END_SRC

** Editing with Markdown

Because I can't always use =org=.

I'd like spell-checking running when editing Markdown.

#+BEGIN_SRC emacs-lisp
  (add-hook 'gfm-mode-hook 'flyspell-mode)
#+END_SRC

Associate =.md= files with GitHub-flavored Markdown.

# #+BEGIN_SRC emacs-lisp
#   (hrs/add-auto-mode 'gfm-mode "\\.md$")
# #+END_SRC

Use =pandoc= to render the results.

#+BEGIN_SRC emacs-lisp
  (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
#+END_SRC

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'gfm-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

Sometimes, though, I don't wanna wrap text. This toggles wrapping with =C-c q=:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c q") 'auto-fill-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 100)
#+END_SRC

** Always switch to temp-buffer after opening.

I want to always move the focus to the just opened temp-buffer (help buffer).

#+BEGIN_SRC emacs-lisp
(add-hook 'temp-buffer-show-hook (lambda () (other-window 1)))
;;(remove-hook 'temp-buffer-window-show-hook (lambda () (other-window 1))
;;(remove-hook 'help-mode-hook (lambda () (other-window 1)))
#+END_SRC


** Linting prose

I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
checker that runs proselint in texty buffers and displays my errors.

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)

  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))

  (add-to-list 'flycheck-checkers 'proselint)
#+END_SRC

Use flycheck in the appropriate buffers:

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook #'flycheck-mode)
  (add-hook 'gfm-mode-hook #'flycheck-mode)
  (add-hook 'text-mode-hook #'flycheck-mode)
  (add-hook 'org-mode-hook #'flycheck-mode)
#+END_SRC

** Enable region case modification

**

#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+END_SRC

** Switch windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)
#+END_SRC

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+END_SRC

** Configure =wrap-region=

#+BEGIN_SRC emacs-lisp
  (wrap-region-global-mode t)
  (wrap-region-add-wrapper "/" "/" nil 'ruby-mode)
  (wrap-region-add-wrapper "`" "`" nil '(markdown-mode ruby-mode))
#+END_SRC

** Split horizontally for temporary buffers

Horizonal splits are nicer for me, since I usually use a wide monitor. This is
handy for handling temporary buffers (like compilation or test output).
--> Removed for now as this messes up temporary buffers.

# #+BEGIN_SRC emacs-lisp
#   (defun hrs/split-horizontally-for-temp-buffers ()
#     (when (one-window-p t)
#       (split-window-horizontally)))

#   (add-hook 'temp-buffer-window-setup-hook
#             'hrs/split-horizontally-for-temp-buffers)
# #+END_SRC

** Use projectile everywhere

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

** Add a bunch of engines for =engine-mode=

Enable [[https://github.com/hrs/engine-mode][engine-mode]] and define a few useful engines.

#+BEGIN_SRC emacs-lisp
  (require 'engine-mode)

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "g")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (engine-mode t)
#+END_SRC

** Do not move frame screen focus along with mouse

#+BEGIN_SRC emacs-lisp
(setq mouse-autoselect-window nil)
#+END_SRC

** Use Discover to get more info from other modules.

#+BEGIN_SRC emacs-lisp
(discover-add-context-menu
 :context-menu '(isearch
              (description "Isearch, occur and highlighting")
              (lisp-switches
               ("-cf" "Case should fold search" case-fold-search t nil))
              (lisp-arguments
               ("=l" "context lines to show (occur)"
                "list-matching-lines-default-context-lines"
                (lambda (dummy) (interactive) (read-number "Number of context lines to show: "))))
              (actions
               ("Isearch"
                ("_" "isearch forward symbol" isearch-forward-symbol)
                ("w" "isearch forward word" isearch-forward-word))
               ("Occur"
                ("o" "occur" occur))
               ("More"
                ("h" "highlighters ..." makey-key-mode-popup-isearch-highlight))))
 :bind "M-s d")
#+END_SRC


* Set custom keybindings
Hit F10 to toggle between =fullscreen= and back.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "<f10>") 'toggle-frame-fullscreen)
(define-key global-map (kbd "<end>") 'org-end-of-line)
(define-key global-map (kbd "<home>") 'org-beginning-of-line)

#+END_SRC

* Programming Language Tools
** GO
*** go-mode-hook
Enable gorepl-mode in go-mode buffers:

#+BEGIN_SRC emacs-lisp
;;(add-hook 'go-mode-hook 'gorepl-mode)
;;(add-hook 'go-mode-hook 'flymake-mode)
(add-hook 'go-mode-hook 'flycheck-mode)
(add-hook 'go-mode-hook 'git-gutter-mode)
;;(remove-hook 'go-mode-hook 'flymake-mode)
#+END_SRC


Exammple of hook with lambda function.
#+BEGIN_SRC emacs-lisp
;  (add-hook 'go-mode-hook
;            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

*** Settings for company-go


#+BEGIN_SRC emacs-lisp
  (setq company-tooltip-limit 20)                      ; bigger popup window
  (setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
  (setq company-echo-delay 0)                          ; remove annoying blinking
  (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing

;;  (add-to-list 'company-backends 'company-go)          ; add company-go to the backends.
#+END_SRC

*** Settings for goflymake

Flycheck settings:

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.go/src/github.com/dougm/goflymake")
   (require 'go-flymake)
#+END_SRC

Flycheck settings:

#+BEGIN_SRC emacs-lisp
 (add-to-list 'load-path "~/gocode/src/github.com/dougm/goflymake")
    (require 'go-flycheck)
#+END_SRC

*** gofmt to format go when saving

#+BEGIN_SRC emacs-lisp
; Use goimports instead of go-fmt
(setq gofmt-command "goimports")
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC
*** Keybindings

Keybindings for gorepl

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "gorepl-mode"
 (define-key gorepl-mode-map (kbd "C-<return>") 'gorepl-eval-line)
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-go-mode-hook ()
  (define-key global-map (kbd "M-.") nil)
  (define-key global-map (kbd "M-,") nil)
  (local-set-key (kbd "M-.") 'godef-jump)
  (local-set-key (kbd "M-,") 'pop-tag-mark)
)
(add-hook 'go-mode-hook 'my-go-mode-hook)
#+END_SRC

*** Links on how to customize
- http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scrat

** Python
*** Settings for company autocompletion.

Add company-jedi to company backends.

#+BEGIN_SRC emacs-lisp
;;  (add-to-list 'company-backends 'company-jedi)          ; add company-jedi to the backends.
#+END_SRC
** Global Flycheck

# #+BEGIN_SRC emacs-lisp
# (use-package flycheck
#   :ensure t
#   :init
# (global-flycheck-mode))
# #+END_SRC

** PATH Settings

#+BEGIN_SRC emacs-lisp
(exec-path-from-shell-copy-env "GOPATH")
#+END_SRC

** Gitgutter

#+BEGIN_SRC emacs-lisp
(global-git-gutter-mode t)
#+END_SRC

** Node-js

*** js2-mode

Load js2-mode for javascript files

#+BEGIN_SRC emacs-lisp
(require 'js2-mode)
(add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))

#+END_SRC

*** Node REPL

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "nodejs-repl-mode"
    (require 'nodejs-repl-eval)
  )
#+END_SRC
*** Keybindings

Keybindings for node REPL.

#+BEGIN_SRC emacs-lisp
(defun my-js2-mode-hook ()
  (local-set-key (kbd "C-<return>") 'nodejs-repl-eval-dwim)
)
(add-hook 'js2-mode-hook 'my-js2-mode-hook)
#+END_SRC
