
#+TITLE: Emacs HRS configuration

* Utility functions

Define a big ol' bunch of handy utility functions.

#+BEGIN_SRC emacs-lisp
  (defun hrs/view-buffer-name ()
    "Display the filename of the current buffer."
    (interactive)
    (message (buffer-file-name)))

  (defun hrs/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
       name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (other-window 1))

  (defun hrs/de-unicode ()
    "Tidy up a buffer by replacing all special Unicode characters
       (smart quotes, etc.) with their more sane cousins"
    (interactive)
    (let ((unicode-map '(("[\u2018\|\u2019\|\u201A\|\uFFFD]" . "'")
                         ("[\u201c\|\u201d\|\u201e]" . "\"")
                         ("\u2013" . "--")
                         ("\u2014" . "---")
                         ("\u2026" . "...")
                         ("\u00A9" . "(c)")
                         ("\u00AE" . "(r)")
                         ("\u2122" . "TM")
                         ("[\u02DC\|\u00A0]" . " "))))
      (save-excursion
        (loop for (key . value) in unicode-map
              do
              (goto-char (point-min))
              (replace-regexp key value)))))

  (defun hrs/beautify-json ()
    "Pretty-print the JSON in the marked region. Currently shells
       out to `jsonpp'--be sure that's installed!"
    (interactive)
    (save-excursion
      (shell-command-on-region (mark) (point) "jsonpp" (buffer-name) t)))

  (defun hrs/unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

  (defun hrs/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun hrs/visit-last-dired-file ()
    "Open the last file in an open dired buffer."
    (end-of-buffer)
    (previous-line)
    (dired-find-file))

  (defun hrs/visit-last-migration ()
    "Open the last file in 'db/migrate/'. Relies on projectile. Pretty sloppy."
    (interactive)
    (dired (expand-file-name "db/migrate" (projectile-project-root)))
    (hrs/visit-last-dired-file)
    (kill-buffer "migrate"))

  (defun hrs/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun hrs/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun hrs/insert-random-string (len)
    "Insert a random alphanumeric string of length len."
    (interactive)
    (let ((mycharset "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstyvwxyz"))
      (dotimes (i len)
        (insert (elt mycharset (random (length mycharset)))))))

  (defun hrs/generate-password ()
    "Insert a good alphanumeric password of length 30."
    (interactive)
    (hrs/insert-random-string 30))
#+END_SRC

* UI preferences
** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Hide certain modes from the modeline

I'd rather have only a few necessary mode identifiers on my modeline. This
either hides or "renames" a variety of major or minor modes using the =diminish=
package.

#+BEGIN_SRC emacs-lisp
  (defmacro diminish-minor-mode (filename mode &optional abbrev)
    `(eval-after-load (symbol-name ,filename)
       '(diminish ,mode ,abbrev)))

  (defmacro diminish-major-mode (mode-hook abbrev)
    `(add-hook ,mode-hook
               (lambda () (setq mode-name ,abbrev))))

  (diminish-minor-mode 'abbrev 'abbrev-mode)
  (diminish-minor-mode 'simple 'auto-fill-function)
  (diminish-minor-mode 'company 'company-mode)
  (diminish-minor-mode 'eldoc 'eldoc-mode)
  (diminish-minor-mode 'flycheck 'flycheck-mode)
  (diminish-minor-mode 'flyspell 'flyspell-mode)
  (diminish-minor-mode 'global-whitespace 'global-whitespace-mode)
  (diminish-minor-mode 'projectile 'projectile-mode)
  (diminish-minor-mode 'ruby-end 'ruby-end-mode)
  (diminish-minor-mode 'subword 'subword-mode)
  (diminish-minor-mode 'undo-tree 'undo-tree-mode)
  (diminish-minor-mode 'yard-mode 'yard-mode)
  (diminish-minor-mode 'yasnippet 'yas-minor-mode)
  (diminish-minor-mode 'wrap-region 'wrap-region-mode)

  (diminish-minor-mode 'paredit 'paredit-mode " π")

  (diminish-major-mode 'emacs-lisp-mode-hook "el")
  (diminish-major-mode 'haskell-mode-hook "λ=")
  (diminish-major-mode 'lisp-interaction-mode-hook "λ")
  (diminish-major-mode 'python-mode-hook "Py")

#+END_SRC
* Editing settings
** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

# #+BEGIN_SRC emacs-lisp
#   (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)
# #+END_SRC

** Look for executables in =/usr/local/bin=.

#+BEGIN_SRC emacs-lisp 
(setq exec-path (append exec-path '("/usr/local/bin")))
#+END_SRC
** Use =company-mode= everywhere

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace. (Commented out for now)

#+BEGIN_SRC emacs-lisp
;  (setq-default indent-tabs-mode nil)
#+END_SRC

** Cleanup buffer tabs to whitespace

Function to run before safe to replace tabs with whitespaces. (Commented out for now)

#
** Configure yasnippet

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs '(
"~/emacs/emp-25.2/.emacs.d/snippets/"
"~/emacs/emp-25.2/.emacs.d/packages/yasnippet-20170624.803/snippets/"
))
  (yas-global-mode 1)
#+END_SRC

I /don’t/ want =ido= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+BEGIN_SRC emacs-lisp
  (setq yas/indent-line nil)
#+END_SRC

** Configure =abbrev-mode=

My email address is too long, so I like to keep some personal information as
abbreviations.

I'm prefixing them with semicolons to avoid collisions with real words.

#+BEGIN_SRC emacs-lisp
  (define-abbrev-table 'global-abbrev-table
    '((";name" "Harry R. Schwartz")
      (";email" "hello@harryrschwartz.com")
      (";tb" "harry@thoughtbot.com")
      (";site" "http://harryrschwartz.com")))
#+END_SRC

blockchain

bc 


Always enable =abbrev-mode=:

#+BEGIN_SRC emacs-lisp
  (setq-default abbrev-mode t)
#+END_SRC

** Configure =ido=

#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
  (ido-ubiquitous-mode 1)
  (flx-ido-mode 1) ; better/faster matching
  (setq ido-create-new-buffer 'always) ; don't confirm to create new buffers
  (ido-vertical-mode 1)
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+END_SRC

** Configure =helm=

#+BEGIN_SRC emacs-lisp
  (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
        helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
        helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
        helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
        helm-ff-file-name-history-use-recentf t
        helm-echo-input-in-header-line t)
#+END_SRC

** Configure =yafolding=

#+BEGIN_SRC emacs-lisp
  (define-key yafolding-mode-map (kbd "<s-S-return>") 'yafolding-hide-parent-element)
  (define-key yafolding-mode-map (kbd "<s-M-return>") 'yafolding-toggle-all) 
  (define-key yafolding-mode-map (kbd "<s-return>") 'yafolding-toggle-element)
#+END_SRC
** Configure =dired=

Do not use _helm_ mode in dired, this causes copy / replace errors. 

#+BEGIN_SRC emacs-lisp

  (defun my-dired-mode-hook ()
    ;; Let us have a key that puts the dired buffer into interactive renaming mode
    (helm-mode 0)
    )

  (add-hook 'dired-mode-hook
            'my-dired-mode-hook)


#+END_SRC

Do not send --dired to ls, this gives error.

#+BEGIN_SRC emacs-lisp
(setq dired-use-ls-dired nil)
#+END_SRC

Do not hide dired details. (mode of dired+)

#+BEGIN_SRC emacs-lisp
(setq diredp-hide-details-initially-flag nil)
#+END_SRC

Reuse the current dired-buffer, stops opening dozens of windows.
#+BEGIN_SRC emacs-lisp
(toggle-diredp-find-file-reuse-dir nil)
#+END_SRC



Load up the assorted =dired= extensions.

#+BEGIN_SRC emacs-lisp
  (require 'dired-x)
  (require 'dired+)
  (require 'dired-open)
#+END_SRC

Open media with the appropriate programs.

#+BEGIN_SRC emacs-lisp
  (setq dired-open-extensions
        '(("pdf" . "evince")
          ("mkv" . "vlc")
          ("mp4" . "vlc")
          ("avi" . "vlc")))
#+END_SRC

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

# #+BEGIN_SRC emacs-lisp
#   (setq-default dired-listing-switches "-lhvA")
# #+END_SRC

Use "j" and "k" to move around in =dired=.

# #+BEGIN_SRC emacs-lisp
#   (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
#   (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
# #+END_SRC

Kill buffers of files/directories that are deleted in =dired=.

#+BEGIN_SRC emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+END_SRC

Always copy directories recursively instead of asking every time.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Ask before recursively /deleting/ a directory, though.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'top)
#+END_SRC

** Configure autocompletion (Company vs Autocomplete)

Disable company mode for python.
#+BEGIN_SRC emacs-lisp
;;(add-to-list 'company-backends 'company-jedi)
(setq company-global-modes '(not python-mode not ruby-mode))
#+END_SRC

Set autocomplete settings:
#+BEGIN_SRC emacs-lisp
     (with-eval-after-load "auto-complete"
       (setq ac-auto-show-menu t)
       (setq ac-auto-start t)
       (setq completion-at-point-functions '(auto-complete))
       (set-face-background 'popup-summary-face "lightgrey")
       (set-face-foreground 'popup-summary-face "black")
       (set-face-background 'popup-menu-summary-face "lightgrey")
       (set-face-underline 'popup-summary-face "lightgrey")
       (set-face-background 'popup-tip-face "lightgrey")
  )
#+END_SRC

** Use =smex= to handle =M-x= with =ido=

#+BEGIN_SRC emacs-lisp
  (smex-initialize)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+END_SRC

** Editing with Markdown

Because I can't always use =org=.

I'd like spell-checking running when editing Markdown.

#+BEGIN_SRC emacs-lisp
  (add-hook 'gfm-mode-hook 'flyspell-mode)
#+END_SRC

Associate =.md= files with GitHub-flavored Markdown.

#
** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'gfm-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

Sometimes, though, I don't wanna wrap text. This toggles wrapping with =C-c q=:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c q") 'auto-fill-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 100)
#+END_SRC

** Always switch to temp-buffer after opening.

I want to always move the focus to the just opened temp-buffer (help buffer).

#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
#+END_SRC

** Enble helm mode by default.
#+BEGIN_SRC emacs-lisp
(helm-mode 1)
#+END_SRC

** Linting prose

I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
checker that runs proselint in texty buffers and displays my errors.

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)

  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))

  (add-to-list 'flycheck-checkers 'proselint)
#+END_SRC

Use flycheck in the appropriate buffers:

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook #'flycheck-mode)
  (add-hook 'gfm-mode-hook #'flycheck-mode)
  (add-hook 'text-mode-hook #'flycheck-mode)
  (add-hook 'org-mode-hook #'flycheck-mode)
#+END_SRC

** Enable region case modification

**

#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+END_SRC

** Switch windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)
#+END_SRC

** Mass editing of =grep= results


I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+END_SRC

** Configure =wrap-region=

#+BEGIN_SRC emacs-lisp
  (wrap-region-global-mode t)
  (wrap-region-add-wrapper "/" "/" nil 'ruby-mode)
  (wrap-region-add-wrapper "`" "`" nil '(markdown-mode ruby-mode))
#+END_SRC

** Split horizontally for temporary buffers

Horizonal splits are nicer for me, since I usually use a wide monitor. This is
handy for handling temporary buffers (like compilation or test output).
--> Removed for now as this messes up temporary buffers.

# #+BEGIN_SRC emacs-lisp
#   (defun hrs/split-horizontally-for-temp-buffers ()
#     (when (one-window-p t)
#       (split-window-horizontally)))

#   (add-hook 'temp-buffer-window-setup-hook
#             'hrs/split-horizontally-for-temp-buffers)
# #+END_SRC

** Use projectile everywhere

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

** Add a bunch of engines for =engine-mode=

Enable [[https://github.com/hrs/engine-mode][engine-mode]] and define a few useful engines.

#+BEGIN_SRC emacs-lisp
  (require 'engine-mode)

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "g")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (engine-mode t)
#+END_SRC

** Do not move frame screen focus along with mouse

#+BEGIN_SRC emacs-lisp
(setq mouse-autoselect-window nil)
#+END_SRC

** Use ALT as the META key and CMD as Hyper.

#+BEGIN_SRC emacs-lisp
(setq mac-option-modifier 'meta)
(setq mac-command-modifier 'super)
(set-keyboard-coding-system nil)
#+END_SRC



** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#

* publishing and task management with Org-mode
** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (org-bullets-mode t)))
#+END_SRC

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

Hide emphasis markers because I view my org text mostly in Emacs itself.
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Show inline images by default when starting org documents.
#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images t)
#+END_SRC

Set the maximal width of these org inline images.
#+BEGIN_SRC emacs-lisp
(setq org-image-actual-width 600)



#+END_SRC

** Task and org-capture management

Hide done items from the agenda view.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-skip-scheduled-if-done t)
#+END_SRC

Store my org files in =~/org=, maintain an inbox in Dropbox, define the location
of an index file (my main todo list), and archive finished tasks in
=~/org/archive.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file "~/org/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))
#+END_SRC

I use [[http://agiletortoise.com/drafts/][Drafts]] to create new tasks, format them according to a template, and
append them to an "inbox.org" file in my Dropbox. This function lets me import
them easily from that inbox file to my index.

#+BEGIN_SRC emacs-lisp
  (defun hrs/copy-tasks-from-inbox ()
    (when (file-exists-p org-inbox-file)
      (save-excursion
        (find-file org-index-file)
        (goto-char (point-max))
        (insert-file-contents org-inbox-file)
        (delete-file org-inbox-file))))
#+END_SRC

I store all my todos in =~/org/index.org=, so I'd like to derive my agenda from
there.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-index-file))
#+END_SRC

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+BEGIN_SRC emacs-lisp
  (defun mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key global-map "\C-c\C-x\C-s" 'mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

Take a =screenshot= into a time stamped unique-named file in the
same directory as the org-buffer and insert a link to this file.

#+BEGIN_SRC emacs-lisp
  (defun take-org-screenshot ()
    "Take a screenshot into a time stamped unique-named file in the
  same directory as the org-buffer and insert a link to this file."
    (interactive)
                                          ;(org-display-inline-images)
    (setq filename
          (concat
           (make-temp-name
            (concat (file-name-nondirectory (buffer-file-name))
                    "_imgs/"
                    (format-time-string "%Y%m%d_%H%M%S_")) ) ".png"))
    (unless (file-exists-p (file-name-directory filename))
      (make-directory (file-name-directory filename)))
                                          ; take screenshot
    (if (eq system-type 'darwin)
        (call-process "screencapture" nil nil nil "-i" filename))
    (if (eq system-type 'gnu/linux)
        (call-process "import" nil nil nil filename))
                                          ; insert into file if correctly taken
    (if (file-exists-p filename)
        (insert (concat "[[file:" filename "]]")))
    )

  (define-key global-map "\C-x\p" 'take-org-screenshot)
#+END_SRC

Function to resize org images, in hundreds of points.

#+BEGIN_SRC emacs-lisp
  (defun org-set-image-width ()
    (interactive)
    (setq width (read-string "Enter org image width: "))
    (setq width (string-to-int width))
    (setq width (* width 100))
    (setq org-image-actual-width width)
    (message "Set org image width to: %s" width)
    )

  (with-eval-after-load "org" (define-key org-mode-map (kbd "s-z") 'org-set-image-width))
#+END_SRC


**** Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =~/org/blog-ideas.org=,
- Keep a running grocery list in =~/org/groceries.org=, and
- Maintain a todo list in =~/org/index.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("b" "Blog idea"
           entry
           (file (org-file-path "blog-ideas.org"))
           "* TODO %?\n")

          ("g" "Groceries"
           checkitem
           (file (org-file-path "groceries.org")))

          ("l" "Today I Learned..."
           entry
           (file+datetree (org-file-path "til.org"))
           "* %?\n")

          ("r" "Reading"
           checkitem
           (file (org-file-path "to-read.org")))

          ("t" "Todo"
           entry
           (file org-index-file)
           "* TODO %?\n")))
#+END_SRC

When I'm starting an org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

# #+BEGIN_SRC emacs-lisp
#   (add-hook 'org-capture-mode-hook 'evil-insert-state)
# #+END_SRC

**** Keybindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC

Hit =C-c i= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (hrs/copy-tasks-from-inbox)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'open-index-file)
#+END_SRC

Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

** Keybindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
  (define-key global-map "\C-ct" 'org-deadline)

(with-eval-after-load "org" (define-key org-mode-map (kbd "s-i") 'org-toggle-inline-images))

#+END_SRC




Hit =C-c i= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (hrs/copy-tasks-from-inbox)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'open-index-file)
#+END_SRC

Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

Remap some handy keybindings defined in emp-keybindings because
org-mode overwrites them.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "org" (define-key org-mode-map (kbd "C-k") nil)
 (define-key org-mode-map [backspace] nil)
 (define-key org-mode-map (kbd "C-'") nil)
 (define-key org-mode-map (kbd "C-,") nil)
 (define-key org-mode-map (kbd "<M-RET>") nil))
#+END_SRC

** Exporting

Allow export to markdown and beamer (for presentations).

#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

Allow =babel= to evaluate Emacs lisp, Ruby, dot, Gnuplot code, or python.

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (dot . t)
     (gnuplot . t)
     (js . t)
     (go . t)
     (python . t)
     (typescript . t)))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Associate the "dot" language with the =graphviz-dot= major mode.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+END_SRC

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+BEGIN_SRC emacs-lisp
  (setq org-export-with-smart-quotes t)
#+END_SRC

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

**** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Include the =minted= package in all of my LaTeX exports.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+END_SRC

**** Exporting projects

I have a few Org project definitions that I maintain in a separate elisp file.

# #+BEGIN_SRC emacs-lisp
#   (load-file ".emacs.d/projects.el")
# #+END_SRC

** TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t)
#+END_SRC

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+END_SRC
** Org electric-pair functions for mark-up
With this in place, all you need to do to wrap a region with mark-up characters is press the corresponding character (*, /, =, _, ~, or +) once.

As an additional benefit, Emacs will automatically insert matching pairs of mark-up characters at
point if there is no region. For example, pressing * will insert ** and leave point between the two
chars so you can continue typing without having to move point.


#+BEGIN_SRC emacs-lisp
(defvar org-electric-pairs '((?/ . ?/) (?= . ?=)
                             (?\_ . ?\_) (?~ . ?~) (?+ . ?+)) "Electric pairs for org-mode.")

(defun org-add-electric-pairs ()
  (setq-local electric-pair-pairs (append electric-pair-pairs org-electric-pairs))
  (setq-local electric-pair-text-pairs electric-pair-pairs))

(add-hook 'org-mode-hook 'org-add-electric-pairs)

#+END_SRC


* Programming Language Tools
** GO
*** go-mode-hook
Enable gorepl-mode in go-mode buffers:

#+BEGIN_SRC emacs-lisp
  ;;(add-hook 'go-mode-hook 'gorepl-mode)
  (add-hook 'go-mode-hook 'flycheck-mode)
  ;;(add-hook 'go-mode-hook 'flycheck-mode)
  (add-hook 'go-mode-hook 'git-gutter-mode)
  (add-hook 'go-mode-hook 'go-eldoc-setup)

  ;; (add-hook 'go-mode-hook 'flycheck-gometalinter-setup)
  ;;(remove-hook 'go-mode-hook 'flymake-mode)
#+END_SRC


Exammple of hook with lambda function.
#+BEGIN_SRC emacs-lisp
;  (add-hook 'go-mode-hook
;            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

*** goflymake and goflycheck

Flymake settings (not needed because flycheck is used):

# #+BEGIN_SRC emacs-lisp
#   (require 'go-flymake)
# #+END_SRC

Flycheck settings:

#+BEGIN_SRC emacs-lisp
  (require 'go-flycheck)
#+END_SRC

*** gofmt to format go when saving

#+BEGIN_SRC emacs-lisp
; Use goimports instead of go-fmt
(setq gofmt-command "goimports")
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

*** Keybindings

Keybindings for gorepl

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "gorepl-mode"
 (define-key gorepl-mode-map (kbd "C-<return>") 'gorepl-eval-line)
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-go-mode-hook ()
    (define-key global-map (kbd "M-.") nil)
    (define-key global-map (kbd "M-,") nil)
    (local-set-key (kbd "M-.") 'godef-jump)
    (local-set-key (kbd "C-M-.") 'godef-jump-other-window)
    (local-set-key (kbd "M-,") 'pop-tag-mark)
    (go-guru-hl-identifier-mode)
  )
  (add-hook 'go-mode-hook 'my-go-mode-hook)
#+END_SRC



*** PATH Settings

#+BEGIN_SRC emacs-lisp
(exec-path-from-shell-copy-env "GOPATH")
#+END_SRC

*** Company

Load company backend for go.
#+BEGIN_SRC emacs-lisp
'(eval-after-load 'company
  (add-to-list 'company-backends 'company-go)
 (add-to-list 'company-backends 'company-elisp))
#+END_SRC



*** Links on how to customize
- http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scrat
 
** Python
*** Python-mode-hook
#+BEGIN_SRC emacs-lisp
        (defun my-python-mode-hook ()
                       (elpy-enable)
                       ;; Disable flymake in Elpy.
                       (setq elpy-modules
                             (quote (elpy-module-company elpy-module-eldoc elpy-module-pyvenv elpy-module-highlight-indentation elpy-module-yasnippet elpy-module-django elpy-module-sane-defaults))
                             )
                       (elpy-mode)
                       (flycheck-mode)
                       (setq elpy-rpc-python-command "python3")
                       (elpy-use-ipython)
                       (setq elpy-rpc-backend "jedi")
                       (company-mode 0)
                       (auto-complete-mode t)
                       (jedi:setup) 
                       (setq python-check-command (concat emacsd "pyflymake.py"))
                       (define-key elpy-mode-map (kbd "C-<return>") 'new-python-eval)
                       (setq elpy-test-runner 'elpy-test-pytest-runner)
                       (setq jedi:complete-on-dot t)
  )


                       
    (add-hook 'python-mode-hook 'my-python-mode-hook)
    ;; (flymake-mode t)
    ;;                   (setq-local flymake-start-syntax-check-on-newline t)
    ;;                   (setq flymake-no-changes-timeout 10000)

#+END_SRC

 

*** Keybindings

#+BEGIN_SRC emacs-lisp
   (defun my-python-keybindings-hook ()
   (define-key python-mode-map (kbd "<tab>") 'py-indent-line)
   (local-set-key (kbd "M-,") 'pop-tag-mark)
               (local-set-key "\C-ca" 'pytest-all)
               (local-set-key "\C-c0" 'pytest-pdb-one)
               (local-set-key "\C-c1" 'pytest-one)
;               (local-set-key (kbd "s-<return>") 'iterm-send-text-clipboard)
   )
   (add-hook 'python-mode-hook 'my-python-keybindings-hook)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "python"
               (define-key python-mode-map  (kbd "s-<return>") nil)
               (define-key python-mode-map (kbd "s-<return>") 'iterm-send-text-clipboard)
)
#+END_SRC    

** Javascript
*** js2-mode
Load typescript-mode for javascript files

#+BEGIN_SRC emacs-lisp
(require 'typescript-mode)
(add-to-list 'auto-mode-alist '("\\.js\\'" . typescript-mode))
#+END_SRC
THe rest below here is not relevant anymore, I use typescript-mode for .js files.
*** Setup Hook

#+BEGIN_SRC emacs-lisp 
    (add-hook 'js2-mode-hook (lambda ()
                               (tern-mode)
                               (add-to-list 'company-backends 'company-tern)
                               (company-mode)
                               (yafolding-mode)
                               (helm-mode)
  ))

#+END_SRC

*** Node REPL

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "nodejs-repl-mode"
    (require 'nodejs-repl-eval)
  )
#+END_SRC
*** Keybindings
Keybindings for node REPL.

#+BEGIN_SRC emacs-lisp 
(defun my-js2-mode-hook ()
  (require 'nodejs-repl-eval)
  (local-set-key (kbd "C-<return>") 'nodejs-repl-eval-dwim)
  (define-key js2-mode-map (kbd "C-x C-e") 'nodejs-repl-send-last-sexp)
  (define-key js2-mode-map (kbd "C-c C-r") 'nodejs-repl-send-region)
  (define-key js2-mode-map (kbd "C-c C-l") 'nodejs-repl-load-file)
  (define-key js2-mode-map (kbd "C-c C-z") 'nodejs-repl-switch-to-repl)
)

  (add-hook 'js2-mode-hook 'my-js2-mode-hook)

#+END_SRC

** JSON

json mode for json files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.json$" . json-mode))
#+END_SRC


Enable yafolding mode and jq mode in json files by default.

#+BEGIN_SRC emacs-lisp
(add-hook 'json-mode-hook 'yafolding-mode)
#+END_SRC

Hook to put in custom keybindings for JSON.

#+BEGIN_SRC emacs-lisp

(defun my-json-mode-hook ()
  (local-set-key (kbd "C-c C-j") 'jq-interactively)
  (flycheck-mode))
(add-hook 'json-mode-hook 'my-json-mode-hook)
#+END_SRC




jq mode for jquery files.
#
** Ruby
Set custom keybindings for inf-ruby.

#+BEGIN_SRC emacs-lisp
(defun my-ruby-mode-hook ()
;;  (define-key global-map (kbd "M-.") nil)
;;  (define-key global-map (kbd "M-,") nil)
(inf-ruby-minor-mode t)
(robe-mode t)
; (inf-ruby)
(local-set-key (kbd "C-<return>") 'ruby-send-line)
; (robe-start)
(auto-complete-mode t)
(yafolding-mode t)
)


(add-hook 'ruby-mode-hook 'my-ruby-mode-hook)
#+END_SRC

Load company backend for ruby.
#+BEGIN_SRC emacs-lisp
(eval-after-load 'company
  '(add-to-list 'company-backends 'company-inf-ruby 'company-robe))
#+END_SRC

** Typescript
*** Setup Hook
Hook to add tide setup, eldoc mode and company mode amongst others. 
#+BEGIN_SRC emacs-lisp

    (defun my-typescript-mode-hook ()
                 (tide-setup)
                (flycheck-mode +1)
                (setq flycheck-check-syntax-automatically '(save mode-enabled))
                (eldoc-mode +1)
                (tide-hl-identifier-mode 0)
                (yafolding-mode)
                ;; company is an optional dependency. You have to
                ;; install it separately via package-install
                (company-mode-on)
                (helm-mode)
    )
  (add-hook 'typescript-mode-hook 'my-typescript-mode-hook 'my-typescript-keybindings-hook)

  (setq tide-tssserver-executable "~/.nvm/versions/node/v6.10.3/bin/tsserver")
  (setq tide-tsserver-process-environment '("TSS_LOG=-level verbose -file /tmp/tss.log"))

#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp

  (defun my-typescript-keybindings-hook ()
    (interactive)
    (define-key typescript-mode-map (kbd "s-n") 'tide-nav)
    (define-key yafolding-mode-map  (kbd "s-<return>") 'yafolding-toggle-element)
    (define-key yafolding-mode-map  (kbd "C-<return>") nil)
    ;;    (local-set-key (kbd "C-<return>") 'iterm-send-text-clipboard)
    (define-key typescript-mode-map (kbd "C-<return>") 'iterm-send-text-clipboard)
    (define-key typescript-mode-map (kbd "C-x C-e") 'nodejs-repl-send-last-sexp)
    (define-key typescript-mode-map (kbd "C-c C-r") 'nodejs-repl-send-region)
    (define-key typescript-mode-map (kbd "C-c C-l") 'nodejs-repl-load-file)
    (define-key typescript-mode-map (kbd "C-c C-z") 'nodejs-repl-switch-to-repl)
    )

#+END_SRC

** Bash

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "shell"
   (define-key sh-mode-map (kbd "M-.") 'ffap)
   (define-key yafolding-mode-map  (kbd "s-<return>") 'yafolding-toggle-element)
   (define-key sh-mode-map (kbd "C-<return>") 'iterm-send-text-clipboard)
  )

#+END_SRC
** JAVA
*** Settings and Keybindings
#+BEGIN_SRC emacs-lisp
(require 'eclim)
(setq eclimd-autostart t)
(setq eclim-print-debug-messages t)
(setq eclimd-default-workspace "~/Documents")

(defun my-java-mode-hook ()
    (eclim-mode t))

(add-hook 'java-mode-hook 'my-java-mode-hook)
(add-hook 'java-mode-hook 'my-java-keybindings-hook)

#+END_SRC

Displaying compilation error messages in echo area.
#+BEGIN_SRC emacs-lisp
(setq help-at-pt-display-when-idle t)
(setq help-at-pt-timer-delay 0.1)
(help-at-pt-set-timer)

#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp

  (defun my-java-keybindings-hook ()
    (interactive)
    (define-key yafolding-mode-map  (kbd "s-<return>") 'yafolding-toggle-element)
    (define-key yafolding-mode-map  (kbd "C-<return>") nil)
    (define-key global-map (kbd "M-.") nil)
    (define-key global-map (kbd "M-,") nil)
    (define-key java-mode-map (kbd "M-.") 'eclim-java-find-declaration)
    (define-key java-mode-map (kbd "M-,") 'pop-tag-mark)
    )

#+END_SRC


*** Company

TODO: Override change made here in [[/Users/avdh/emacs/emp-25.2/.emacs.d/packages/company-emacs-eclim-20170104.743/company-emacs-eclim.el::105][company-emacs-eclim]]

#+BEGIN_SRC emacs-lisp
(require 'company)
(require 'company-emacs-eclim)
(company-emacs-eclim-setup)
(global-company-mode t)
(setq company-emacs-eclim-ignore-case t)

(setq company-auto-complete-chars (quote (32 95 41 46)))
(setq company-idle-delay 0.3)
(setq company-minimum-prefix-length 0)

#+END_SRC 

*** Autocomplete (Use company-mode).
 # #+BEGIN_SRC emacs-lisp
 # ;; regular auto-complete initialization
 # (require 'auto-complete-config)
 # (ac-config-default)

 # ;; add the emacs-eclim source
 # (require 'ac-emacs-eclim)
 # (ac-emacs-eclim-config)

 # #+END_SRC


* General Custom Keybindings
Hit F10 to toggle between =fullscreen= and back.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "s-c") 'kill-ring-save)
(define-key global-map (kbd "s-a") 'mark-whole-buffer)
(define-key global-map (kbd "s-l") 'goto-line)
(define-key global-map (kbd "M-f") 'company-files)
(define-key global-map (kbd "M-s-.") 'ffap)
(define-key global-map (kbd "<f10>") 'maximize-frame-toggle)
(define-key global-map (kbd "<end>") 'org-end-of-line)
(define-key global-map (kbd "<home>") 'org-beginning-of-line)
(define-key global-map (kbd "M-d") nil)
(key-chord-define-global "xj" 'helm-mini)
(global-set-key (kbd "<f5>") 'hrs/split-window-below-and-switch)
(global-set-key (kbd "<f6>") 'hrs/split-window-right-and-switch)
(global-set-key (kbd "<f7>") 'other-window)
(global-set-key (kbd "<f8>") 'delete-window)
(global-set-key (kbd "<f11>") 'helm-all-mark-rings)
(global-set-key (kbd "<f12>") 'helm-semantic-or-imenu)
(global-set-key (kbd "s-s") 'helm-ag)
(global-set-key (kbd "C-c r") 'helm-recentf)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-x b") 'helm-mini)
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "C-x C-f") 'find-file)
(global-set-key (kbd "C-x M-f") 'helm-find-files)
(global-set-key (kbd "s-u") 'revert-buffer)
(global-set-key (kbd "s-d") 'iterm-goto-filedir-or-home)

#+END_SRC

* Misc Tools
** =magit=

Magit custom settings for References buffer and log buffer.

#+BEGIN_SRC emacs-lisp
(setq magit-refs-show-commit-count nil)
(setq magit-log-arguments '("-n256" "--graph" "--decorate" "--color"))
;(setq magit-refs-margin nil)
#+END_SRC

Save window configuration before Ediff and restore afterwards.

#+BEGIN_SRC emacs-lisp
(defvar my-ediff-last-windows nil)

(defun my-store-pre-ediff-winconfig ()
  (setq my-ediff-last-windows (current-window-configuration)))

(defun my-restore-pre-ediff-winconfig ()
  (set-window-configuration my-ediff-last-windows))

(add-hook 'ediff-before-setup-hook #'my-store-pre-ediff-winconfig)
(add-hook 'ediff-quit-hook #'my-restore-pre-ediff-winconfig)
#+END_SRC


Hook for magit-mode to disable helm.
#+BEGIN_SRC emacs-lisp
  (defun my-magit-mode-hook ()
              (helm-mode 0)
  )
  (add-hook 'magit-mode-hook 'my-magit-mode-hook)
#+END_SRC

** Gitgutter

#+BEGIN_SRC emacs-lisp
(global-git-gutter-mode t)
#+END_SRC

** Flycheck

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(flycheck-typescript-tslint-config "~/tslint.json"))

#+END_SRC

** Discover (for context menus)
Use Discover to get more info from other modules.

#+BEGIN_SRC emacs-lisp
(global-discover-mode)
#+END_SRC

Add a context menu per module:

*** Isearch

#+BEGIN_SRC emacs-lisp
(discover-add-context-menu
 :context-menu '(isearch
              (description "Isearch, occur and highlighting")
              (lisp-switches
               ("-cf" "Case should fold search" case-fold-search t nil))
              (lisp-arguments
               ("=l" "context lines to show (occur)"
                "list-matching-lines-default-context-lines"
                (lambda (dummy) (interactive) (read-number "Number of context lines to show: "))))
              (actions
               ("Isearch"
                ("_" "isearch forward symbol" isearch-forward-symbol)
                ("w" "isearch forward word" isearch-forward-word))
               ("Occur"
                ("o" "occur" occur))
               ("More"
                ("h" "highlighters ..." makey-key-mode-popup-isearch-highlight))))
 :bind "M-d s")
#+END_SRC





*** Yafolding
Still to be set correctly.

#+BEGIN_SRC emacs-lisp 
(discover-add-context-menu
 :context-menu '(yafolding
              (description "Isearch, occur and highlighting")
              (lisp-switches)
              (lisp-arguments)
              (actions
               ("yafolding"
                ("h" "hide element" yafolding-hide-element)
                ("s" "show element" yafolding-show-element)
                ("t" "toggle element" yafolding-toggle-element)
                ("H" "hide all" yafolding-hide-all)
                ("S" "show all" yafolding-show-all)
                ("T" "toggle all" yafolding-toggle-all)
                ("p" "go parent element" yafolding-go-parent-element)
                ("P" "hide parent element" yafolding-hide-parent-element)))) 
 :bind "M-d y"
 :mode 'yafolding
 :mode-hook 'yafolding-mode-hook 
)
#+END_SRC

** Company

#+BEGIN_SRC emacs-lisp
    (setq company-tooltip-limit 20)                      ; bigger popup window
    (setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
    (setq company-echo-delay 0)                          ; remove annoying blinking
    (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
#+END_SRC

Set company-yasnippet global keybinding.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "M-e") 'company-yasnippet)
#+END_SRC

** Yasnippets.
# Load company backend for yasnippets.
# #+BEGIN_SRC emacs-lisp
# (eval-after-load 'company
#   '(add-to-list 'company-backends 'company-yasnippet))
# #+END_SRC

** helm-descbinds
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-h b") 'helm-descbinds)
#+END_SRC

** helm-ag for searching.

#+BEGIN_SRC emacs-lisp 
  (define-key global-map (kbd "M-s h") 'helm-ag)
  (eval-after-load 'helm-ag
    (custom-set-variables
     '(helm-ag-base-command "ag --nocolor --nogroup --ignore-case")
     '(helm-ag-command-option "--all-text")
     '(helm-ag-insert-at-point 'symbol)
     '(helm-follow-mode-persistent t)))
#+END_SRC

** helm-imenu for navigating in buffer.

#+BEGIN_SRC emacs-lisp 
    (eval-after-load 'helm-semantic-or-imenu
      (custom-set-variables
       '(helm-follow-mode-persistent t)))
#+END_SRC

** Maxframe to maximize emacs frame to just under window width.

Defined function to toggle between maximized and restored.
#+BEGIN_SRC emacs-lisp 

(require 'maxframe)
(add-hook 'window-setup-hook 'maximize-frame t)

(defvar frame-maximized 1)
(defun maximize-frame-toggle ()
"Doc-string for `my-switch` function."
(interactive)
  (cond
   ((= frame-maximized 0)
    (maximize-frame) 
      (setq frame-maximized 1))
   ((= frame-maximized 1)
     (restore-frame)
      (setq frame-maximized 0)) ) )

#+END_SRC
** Iterm2 Integration
*** Open Iterm2 in directory of buffer file.

This one return the _directory_ of the file currently opened. If it is a *scratch* buffer or something
like that, it simply returns the home directory.

#+BEGIN_SRC emacs-lisp

(defun get-file-dir-or-home ()
  "If inside a file buffer, return the directory, else return home"
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
	"~/"
      (file-name-directory filename))))
#+END_SRC

This one allow me to cd to the directory of the file I am editing in emacs. If I am in a *scratch*
buffer or something like that, it cd to the $HOME directory. It then focus the =iTerm2= app.

#+BEGIN_SRC emacs-lisp
  (defun iterm-goto-filedir-or-home ()
    "Go to present working dir and focus iterm"
    (interactive)
    (do-applescript
     (concat
      " tell application \"iTerm2\"\n"
      "   tell the current session of current window\n"
      (format "     write text \"cd %s\" \n" (get-file-dir-or-home))
      "   end tell\n"
      " end tell\n"
      " do shell script \"open -a iTerm\"\n"
      ))
                        (shell-command "sleep 0.5")
                        (do-applescript "tell application \"System Events\" to keystroke {tab} using {command down}")
  (message (concat (get-file-dir-or-home) " opened in iTerm2."))
    ) 
#+END_SRC

*** Send Text to Iterm2

#+BEGIN_SRC emacs-lisp
  ;;; iterm.el - Send text to a running iTerm instance

  (require 'pcase)
  (require 'thingatpt)

  ;; To match SublimeText's key binding:
  ;; (global-set-key (kbd "<C-return>") 'iterm-send-text)

  (defvar iterm-default-thing 'line
    "The \"thing\" to send if no region is active.
  Can be any symbol understood by `bounds-of-thing-at-point'.")

  (defvar iterm-empty-line-regexp "^[[:space:]]*$"
    "Regexp to match empty lines, which will not be sent to iTerm.
  Set to nil to disable removing empty lines.")

  (defun iterm-escape-string (str)
    (let* ((str (replace-regexp-in-string "\\\\" "\\\\" str nil t))
           (str (replace-regexp-in-string "\"" "\\\"" str nil t)))
      str))

  (defun iterm-last-char-p (str char)
    (let ((length (length str)))
      (and (> length 0)
           (char-equal (elt str (- length 1)) char))))

  (defun iterm-chop-newline (str)
    (let ((length (length str)))
      (if (iterm-last-char-p str ?\n)
          (substring str 0 (- length 1))
        str)))

  (defun iterm-maybe-add-newline (str)
    (if (iterm-last-char-p str ? )
        (concat str "\n")
      str))

    (defun enclose-brackets (str)
      ;;        (let (result ""))
      (setq str (concatenate  'string str "\n"))
          str)


  (defun iterm-handle-newline (str)
    (iterm-maybe-add-newline (iterm-chop-newline str)))

  (defun iterm-maybe-remove-empty-lines (str)
    (if iterm-empty-line-regexp
        (let ((regexp iterm-empty-line-regexp)
              (lines (split-string str "\n")))
          (mapconcat #'identity
                     (delq nil (mapcar (lambda (line)
                                         (unless (string-match-p regexp line)
                                           line))
                                       lines))
                     "\n"))
      str))
#+END_SRC

#+BEGIN_SRC emacs-lisp
          (defun iterm-send-string (str)   
            "Send STR to a running iTerm instance."
            (let* ((str (iterm-maybe-remove-empty-lines str))
                   (str (iterm-handle-newline str))
                   (str (iterm-escape-string str)))
              (shell-command (concat "osascript "
                                     "-e 'tell app \"iTerm2\"' "
                                     "-e 'tell current window' "
                                     "-e 'tell current session' "
                                     "-e 'write text \"" str "\"' "
                                     "-e 'end tell' "
                                     "-e 'end tell' "
                                     "-e 'end tell' ")))
    ;    (do-applescript "tell application \"iTerm2\" to activate")
    ;    (shell-command "sleep 1.5")
    ;    (do-applescript "tell application \"System Events\" to keystroke {tab} using {command down}")
      )
            (defun iterm-send-text-clipboard ()
              (interactive) 
              (copy-region-as-kill 0 0 t)
  ;;            (new-python-get-text)
          ;; Could cut op the osa script into seperate file. 
                              (shell-command (concat "osascript "
              ;                                     "-e 'set the clipboard to \"" str "\"' "
          ;                                         "-e 'tell application \"iTerm2\"' "
          ;                                         "-e 'activate' "
          ;                                         "-e 'end tell' "
                                                   "-e 'tell application \"iTerm\" to activate' "
                                                   "-e 'tell application \"System Events\" to tell process \"iTerm2\"' "
                                                   "-e 'keystroke \"v\" using {command down}' "
          ;                                         "-e 'key down {return}' "
          ;                                         "-e 'key up {return}' "
          ;                                         "-e 'keystroke \"v\" using {command down}' "
                                                   "-e 'end tell' "
          ;                                         "-e 'end tell' "
                                                   ))
                              (shell-command "sleep 0.5")
                              (do-applescript "tell application \"System Events\" to tell process \"iTerm2\" to keystroke return")
                              (shell-command "sleep 0.5")
                              (do-applescript "tell application \"System Events\" to keystroke {tab} using {command down}")
                              (message "Command pasted and executed into iTerm2.")
                              )


                        (defun iterm-text-bounds ()
                          (pcase-let ((`(,beg . ,end) (if (use-region-p)
                                                          (cons (region-beginning) (region-end))
                                                        (bounds-of-thing-at-point
                                                         iterm-default-thing))))
                            (list beg end)))

                        (defun iterm-send-text (beg end)
                          "Send buffer text in region from BEG to END to iTerm.
                        If called interactively without an active region, send text near
                        point (determined by `iterm-default-thing') instead."
                          (interactive (iterm-text-bounds))
                          (let ((str (buffer-substring-no-properties beg end)))
                            (iterm-send-string str))
                          (forward-line 1)
                           (message "Command written into iTerm2.")
        )

                        (defun iterm-send-text-brackets (beg end)
                          "Send buffer text in region from BEG to END to iTerm.
                        If called interactively without an active region, send text near
                        point (determined by `iterm-default-thing') instead."
                          (interactive (iterm-text-bounds))
                          (let ((str (buffer-substring-no-properties beg end)))
                            (setq str (enclose-brackets str))
                            (message str)
                          (forward-line 1)))
                        (provide 'iterm)
#+END_SRC

*** Get Text Functions iPython Kootenpv

#+BEGIN_SRC emacs-lisp

(defun new-python-get-start ()
  (interactive)
  (ignore-errors
    (while (looking-at "[ ]*$")
      (next-line)
      ))
  (move-end-of-line 1)
  (search-backward-regexp "^[@a-zA-Z0-9#\[\{]" 0 t)
  (when (or (looking-at "else") (looking-at "elif") (looking-at "except") (looking-at "finally"))
    (search-backward-regexp "^if" 0 t)
    )
  (ignore-errors
    (previous-line)
    (while (looking-at "[@a-zA-Z]")
      (previous-line))
    (next-line)
    )
  (point)
  )

(defun new-python-get-end ()
  (interactive)
  (ignore-errors
    (while (looking-at "^[@a-zA-Z0-9#\[\{]")
      (next-line)))
  (if (search-forward-regexp "^[@a-zA-Z0-9#\[\{]" (point-max) t)
      (progn (move-beginning-of-line 1)
             (when (or (looking-at "elif") (looking-at "else"))
               (search-forward-regexp "^else" (point-max) t)
               (search-forward-regexp "^[@a-zA-Z0-9#\[\{]" (point-max) t)
               (left-char 1))
             (when (or (looking-at "except"))
               (search-forward-regexp "^except" (point-max) t)
               (search-forward-regexp "^[@a-zA-Z0-9#\[\{]" (point-max) t)
               (left-char 1))
             (when (or (looking-at "finally"))
               (search-forward-regexp "^finally" (point-max) t)
               (search-forward-regexp "^[@a-zA-Z0-9#\[\{]" (point-max) t)
               (left-char 1))
             (point))
    (point-max))
  )

(defun new-python-get-text ()
  (interactive)
  (ignore-errors
    (let ((start (new-python-get-start))
          (end (new-python-get-end)))
      (when (eq (point-max) end)
        (goto-char end))
      (kill-ring-save start end)
      ))
  )

#+END_SRC
